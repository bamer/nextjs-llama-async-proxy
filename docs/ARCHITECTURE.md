# Architecture Documentation

This document describes the technical architecture of the Llama Async Proxy Dashboard.

## System Overview

The application follows a clean client-server architecture with all communication flowing through Socket.IO:

```
┌─────────────────────────────────────┐
│           Browser Client            │
│  ┌─────────────────────────────┐   │
│  │      Vanilla JavaScript     │   │
│  │  ┌─────┐ ┌─────┐ ┌─────┐  │   │
│  │  │Router│ │State│ │UI   │  │   │
│  │  └─────┘ └─────┘ └─────┘  │   │
│  └───────────┬───────────────┘   │
│              │ Socket.IO         │
└──────────────│──────────────────┘
               │
        WebSocket / HTTP
               │
┌──────────────│──────────────────┐
│     Node.js Server             │
│  ┌───────────────┬───────────┐ │
│  │   Express    │Socket.IO  │ │
│  │  (static)    │ (API)     │ │
│  └──────┬────────┴─────┬──────┘ │
│         │              │        │
│         ▼              ▼        │
│  ┌──────────────────────────┐  │
│  │     SQLite Database      │  │
│  └──────────────────────────┘  │
└───────────────────────────────┘
```

## Key Architectural Decisions

### 1. Server-Owned State

The server is the single source of truth for all application state:

- **Models**: Stored in SQLite, modified only via Socket.IO events
- **Metrics**: Collected by server, broadcast to all clients
- **Logs**: Generated by server's Winston logger, broadcast to clients
- **Configuration**: Stored in SQLite, retrieved via Socket.IO

Clients never modify state directly. They emit "intents" and the server broadcasts the resulting state.

### 2. Socket.IO-Only Communication

No REST APIs exist in this application. All data flows through Socket.IO:

- **Request-Response**: Client sends request, server responds to that specific client
- **Broadcasts**: Server pushes updates to all connected clients

This eliminates:
- CORS issues
- Separate API server requirements
- REST endpoint maintenance

### 3. Event-Driven Architecture

Components subscribe to state changes rather than polling:

```javascript
// Frontend state manager
stateManager.subscribe('models', (models) => {
  // Called whenever models change
  this.updateModelList(models);
});
```

The server broadcasts state changes automatically:

```javascript
// Backend
function broadcastState(models) {
  io.emit('models:list', {
    type: 'broadcast',
    event: 'models:list',
    data: { models },
    timestamp: Date.now()
  });
}
```

### 4. Vanilla JavaScript Frontend

No frameworks on the frontend:

| Feature | Implementation |
|---------|---------------|
| Components | Custom `Component` base class |
| Routing | History API-based `Router` |
| State | Event-driven `StateManager` |
| Styling | Pure CSS with CSS variables |
| Templating | JavaScript template literals |

## Component Model

### Component Class Hierarchy

```
Component (base class)
├── DashboardPage
├── ModelsPage
├── MonitoringPage
├── ConfigurationPage
├── SettingsPage
├── LogsPage
└── Layout Components
```

### Component Lifecycle

```
┌─────────────────────────────────────────────────────┐
│ init()          - Initialize state                  │
├─────────────────────────────────────────────────────┤
│ mount(parent)   - Create DOM, bind events          │
├─────────────────────────────────────────────────────┤
│ render()        - Return DOM element               │
├─────────────────────────────────────────────────────┤
│ update()        - Patch DOM, rebind events         │
├─────────────────────────────────────────────────────┤
│ destroy()       - Cleanup, remove DOM             │
└─────────────────────────────────────────────────────┘
```

### Example Component

```javascript
class DashboardPage extends Component {
  constructor(props) {
    super(props);
    this.state = {
      models: props.models || [],
      metrics: props.metrics || null
    };
  }

  getInitialState() {
    return { models: [], metrics: null };
  }

  render() {
    return Component.h('div', { className: 'dashboard-page' },
      Component.h('h1', {}, 'Dashboard'),
      Component.h(MetricsGrid, { metrics: this.state.metrics })
    );
  }

  getEventMap() {
    return {
      'click [data-action="refresh"]': 'handleRefresh'
    };
  }

  handleRefresh() {
    stateManager.getMetrics();
  }
}
```

## State Management

### StateManager

The `StateManager` class provides:

1. **State Storage**: Centralized state object
2. **Subscriptions**: Components subscribe to state changes
3. **Socket.IO Integration**: Requests and broadcasts
4. **Request Queue**: Queue requests during disconnection

```javascript
class StateManager {
  constructor() {
    this.state = {};
    this.listeners = new Map();
    this.socket = null;
  }

  // Subscribe to state changes
  subscribe(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key).add(callback);
  }

  // Update state and notify listeners
  set(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;
    this._notify(key, value, oldValue);
  }

  // Request-response via Socket.IO
  async request(event, data) {
    if (this.connectionStatus !== 'connected') {
      this.requestQueue.push({ event, data });
      return;
    }
    return this.socket.request(event, data);
  }
}
```

### State Flow

```
┌──────────────┐     Socket.IO      ┌──────────────┐
│  Component   │ ───────────────── │ StateManager │
│              │ ◄── subscribe ─── │              │
└──────────────┘                   └──────┬───────┘
                                        │
                                        │ set(key, value)
                                        ▼
                                ┌──────────────┐
                                │   _notify()  │
                                └──────┬───────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    ▼                  ▼                  ▼
            ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
            │ Listener 1 │    │ Listener 2 │    │ Listener 3 │
            └─────────────┘    └─────────────┘    └─────────────┘
```

## Routing

### Router Class

Uses the History API for client-side routing:

```javascript
class Router {
  constructor(options = {}) {
    this.routes = new Map();
    this.rootElement = options.root;
    this.beforeHooks = [];
    this.afterHooks = [];
  }

  register(path, handler) {
    const pattern = this._pathToRegex(path);
    this.routes.set(pattern, { path, pattern, handler });
    return this;
  }

  navigate(path) {
    window.history.pushState({}, '', path);
    this._handleRouteChange(path);
  }

  start() {
    window.addEventListener('popstate', (e) => {
      this._handleRouteChange(window.location.pathname);
    });
  }
}
```

### Route Definition

```javascript
router.register('/', () => new DashboardController({}));
router.register('/models', () => new ModelsController({}));
router.register('/monitoring', () => new MonitoringController({}));
router.register('/configuration', () => new ConfigurationController({}));
router.register('/settings', () => new SettingsController({}));
router.register('/logs', () => new LogsController({}));
```

## Server Architecture

### Request Handling Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    Socket.IO Server                        │
│  ┌─────────────────────────────────────────────────┐    │
│  │              Connection Handler                  │    │
│  └─────────────────────────────────────────────────┘    │
│                          │                                │
│         ┌────────────────┼────────────────┐                │
│         ▼                ▼                ▼                │
│  ┌───────────┐   ┌───────────┐   ┌───────────┐          │
│  │  Models   │   │  Metrics  │   │   Logs    │          │
│  │ Handlers │   │ Handlers │   │ Handlers │          │
│  └─────┬─────┘   └─────┬─────┘   └─────┬─────┘          │
│        │               │               │                 │
│        └───────────────┴───────────────┘                 │
│                          │                              │
│                          ▼                              │
│               ┌─────────────────────┐                  │
│               │    Database        │                  │
│               │  (better-sqlite3)  │                  │
│               └─────────────────────┘                  │
└─────────────────────────────────────────────────────────────┘
```

### Event Handler Pattern

```javascript
function setupEventHandlers(io, db) {
  io.on('connection', (socket) => {
    // Handle request
    socket.on('models:list', async (request) => {
      const requestId = request?.requestId || generateRequestId();
      try {
        const models = db.getModels();
        socket.emit('models:list:result', {
          type: 'response',
          event: 'models:list',
          success: true,
          data: { models },
          requestId,
          timestamp: Date.now()
        });
      } catch (error) {
        socket.emit('models:list:result', {
          type: 'response',
          event: 'models:list',
          success: false,
          error: { code: 'LIST_MODELS_FAILED', message: error.message },
          requestId,
          timestamp: Date.now()
        });
      }
    });
  });
}
```

### Metrics Collection

```javascript
function startMetricsCollection(io, db) {
  setInterval(async () => {
    const metrics = {
      cpu_usage: getCpuUsage(),
      memory_usage: getMemoryUsage(),
      disk_usage: getDiskUsage(),
      uptime: process.uptime()
    };
    
    db.saveMetrics(metrics);
    
    io.emit('metrics:update', {
      type: 'broadcast',
      event: 'metrics:update',
      data: { metrics },
      timestamp: Date.now()
    });
  }, 10000); // Every 10 seconds
}
```

## Database Schema

### SQLite Database

The application uses SQLite via `better-sqlite3` for persistence:

```
data/
└── llama-dashboard.db
    ├── models          # Model configurations
    ├── metrics        # Historical metrics
    ├── logs           # Application logs
    ├── server_config  # Server configuration
    └── metadata       # Arbitrary key-value storage
```

### Database Class

```javascript
class Database {
  constructor(dbPath) {
    this.db = require('better-sqlite3')(dbPath);
    this.init();
  }

  init() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS models (...);
      CREATE TABLE IF NOT EXISTS metrics (...);
      CREATE TABLE IF NOT EXISTS logs (...);
      CREATE TABLE IF NOT EXISTS server_config (...);
      CREATE TABLE IF NOT EXISTS metadata (...);
    `);
  }

  // CRUD operations for each table
  getModels() { ... }
  saveModel(model) { ... }
  // ... etc
}
```

## Performance Considerations

### Frontend Optimizations

1. **Component Patching**: DOM diffing algorithm updates only changed elements
2. **Event Delegation**: Events bound at container level, not individual elements
3. **State Subscriptions**: Only affected components re-render

### Backend Optimizations

1. **Metrics Interval**: 10-second collection interval balances freshness and performance
2. **Log Queue**: Maximum 500 entries prevents memory bloat
3. **Connection Recovery**: 2-minute window allows reconnection after network issues

### Socket.IO Tuning

```javascript
const io = new Server(server, {
  path: '/llamaproxws',
  pingTimeout: 60000,      // 60s ping timeout
  pingInterval: 25000,     // 25s ping interval
  maxHttpBufferSize: 1e8, // 100MB max message
  transports: ['websocket'] // WebSocket only
});
```

## Security Considerations

1. **No Authentication**: Application is designed for local/network use only
2. **CORS Open**: `origin: '*'` allows any origin
3. **No Input Validation**: Minimal validation in demo implementation
4. **No Rate Limiting**: Could be added for production

For production deployment, consider:
- Adding authentication middleware
- Implementing rate limiting
- Adding input validation
- Using CORS restrictions

## Extensibility

### Adding New Features

1. **New Page**: Create controller in `public/js/pages/`, register route
2. **New API Event**: Add handler in `server.js`
3. **New Database Table**: Add to `Database.init()`, create methods

### Database Migration

```javascript
class Database {
  // Check current version
  getVersion() {
    return this.db.prepare('PRAGMA user_version').get()?.version || 0;
  }

  migrate() {
    const current = this.getVersion();
    if (current < 1) {
      // Run migration to version 1
      this.db.exec('ALTER TABLE models ADD COLUMN new_field TEXT');
      this.db.pragma('user_version = 1');
    }
  }
}
```
